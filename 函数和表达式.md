#  Kotlin函数式编程

面向对象设计是以类为单位，将一组状态属性和处理状态的逻辑封装在一个单一的类中，由于这样的封装，因此类内的成员函数是可以共享类内不的所有成员变量的，即共享和共同管理状态。而如果类成员变量是构造时传入的外部对象，这个对象就可能在多处被修改，但是由于是引用，人和地方对这个对象的修改，都会影响全局而造成我们类中的函数的行为不可预估。这就是函数式编程中提到的副作用。

<pre><code>
var tokenItems = mutableListOf<String>()
class TokenManager(var tokenItems: List<String>)

fun TokenManager.dump() { items.forEach { println("$it")} } // 为类增加成员函数，扩展类

val tokenManager = TokenManager(tokenItems)

tokenManager.dump() //没有内容被打印

tokenItems.add("token1")

tokenManager.dump() //打印Token1
</code></pre>

TokenManager中的成员函数dump的行为依赖函数外部的类成员属性的状态，因此，单从dump函数的逻辑，我们是没办法判断出dump的行为。开发人员单看dump函数式不可能知道，是否还有别的地方修改了items里面的数据。

纯函数机遇不可变属性，对象拷贝和无状态函数来消除副作用，从而达到易测试，且线程安全。

<pre><code>
fun dumpAllToken(val items: List<String>) {
    items.forEach { println(it) }
}

var tokenItems = mutableListOf<String>("hello")

dumpAllToken(listOf(tokenItems))

</code></pre>

## 基本概念

### Top-Level 函数

Kotlin语言中，package下直接定义的函数为Top-Level函数，Package下可以直接通过函数名对Top-Level函数进行调用。上面代码中的dumpAllToken函数就是一个Top-Level函数。

## lambdas 表达式

lambdas指的是将一小段代码作为闭包传入到其它函数。我们可以将我们的逻辑，通过lambdas的形式注入到库函数中，而且Kotlin的标准类库大量使用lambdas来实现对标准库的扩展。Kotlin还支持Lambdas with recevier特性，Receiver就是lambdas执行的目标对象，我们可以理解为调用Receiver对象的一个扩展的类成员方法。

## 高阶函数的运用

## 处理集合类

## 函数式响应编程 FRP

## 函数式编程与面向接口编程结合
