#  Kotlin函数式编程

面向对象设计是以类为单位，将一组状态属性和处理状态的逻辑封装在一个单一的类中，由于这样的封装，因此类内的成员函数是可以共享类内不的所有成员变量的，即共享和共同管理状态。而如果类成员变量是构造时传入的外部对象，这个对象就可能在多处被修改，但是由于是引用，人和地方对这个对象的修改，都会影响全局而造成我们类中的函数的行为不可预估。这就是函数式编程中提到的副作用。

<pre><code>
var tokenItems = mutableListOf<String>()
class TokenManager(var tokenItems: List<String>)

fun TokenManager.dump() { items.forEach { println("$it")} } // 为类增加成员函数，扩展类

val tokenManager = TokenManager(tokenItems)

tokenManager.dump() //没有内容被打印

tokenItems.add("token1")

tokenManager.dump() //打印Token1
</code></pre>

TokenManager中的成员函数dump的行为依赖函数外部的类成员属性的状态，因此，单从dump函数的逻辑，我们是没办法判断出dump的行为。开发人员单看dump函数式不可能知道，是否还有别的地方修改了items里面的数据。

纯函数机遇不可变属性，对象拷贝和无状态函数来消除副作用，从而达到易测试，且线程安全。

<pre><code>
fun dumpAllToken(val items: List<String>) {
    items.forEach { println(it) }
}

var tokenItems = mutableListOf<String>("hello")

dumpAllToken(listOf(tokenItems))

</code></pre>

## 基本概念

### Top-Level 函数

Kotlin语言中，package下直接定义的函数为Top-Level函数，Package下可以直接通过函数名对Top-Level函数进行调用。上面代码中的dumpAllToken函数就是一个Top-Level函数。

## Lambdas 表达式 和 高阶函数（Higher Order Function）

### Lambdas

lambdas指的是将一小段代码作为闭包传入到其它函数，也可以赋值给变量来保存。我们可以将我们的逻辑，通过lambdas的形式注入到库函数中，而且Kotlin的标准类库大量使用lambdas来实现对标准库的扩展。Kotlin还支持Lambdas with recevier特性，Receiver就是lambdas执行的目标对象，我们可以理解为调用Receiver对象的一个扩展的类成员方法。同时lambdas还可以赋值给变量，在开发过程中，保存或者传递lambdas给函数会非常频繁。在Java的早期版本，我们必须要通过内部类来封装这些轻量的代码块，而lambdas实现同样的作用且代码会更加简介。

#### Lambdas 与 collections

我们对我们的代码进行设计，和重构的一个一个很重要的目标就是消除代码重复（冗余）。在Kotlin的函数式标准库为我们提供了一套函数来支持以一种通用的模式来操作集合，我们通过Lambdas的形式将我们的代码注入到库函数中来让我们的代码和标准库合二为一来实现最终的目标。

我们分用函数式和非函数式两种风格实现找到一组人中的最大年纪,并将这个人的纪录打印出来。

首先定义一个People类来代表人

<pre><code>
data class Person(val name: String, val age: Int)

fun printTheOldestAge(people: List&lt;Person&gt;) {
    var maxAge = 0
    var theOldest: Person? = null
    for (person in people) {
        if (person.age > maxAge) {
            maxAge = person.age
            theOldest = person
        }
    }
    println("年龄最大的人是： $person ")
}

// function version

val people = listOf(Person("Leo", 35), Person("Lucy", 28))

val theOldestPerson = people.maxBy { it.age }

println("年龄最大的人是： $theOldestPerson ")

</code></pre>

#### lambdas 语法

上面提到lambdas可以赋值给变量，来实现多处重用，但是，更多的时候是在定义的同时传递给函数。

<pre><code>
// 一个lambdas
{ x: Int, y: Int -> x + y}
</code></pre>

lambdas中的代码必须使用打括号“{}”来包含，括号内最开始是lambdas的参数列表，使用->来将参数列表和代码部分分开。我们可以理解，lambdas是在“{}”同时完成了函数声明和实现，类型为{x:Int, y:Int} -> Int,我们可以将这个lambds传给任何以这个类型为入参的函数。

<pre><code>
fun process(items: List&lt;Int&gt;, catulator:(Int, Int) -> Int) {

}

process(items) { x: Int, y: Int -> x + y }

</code></pre>

可以将lambdas直接赋值给一个变量。

<pre><code>

val sum = { x: Int, y: Int -> x + y }

println(sum(1, 2))// 打印输出3

</code></pre>

也可以通过后跟小括号“()”来直接调用执行一个表达式。

<pre><code>
&gt;&gt;&gt; { println(42) }()

42
</code></pre>

这样执行一个Lambdas虽然没有什么问题，但是会让我们感觉有点奇怪。一种可读性更高的写法是使用Kotlin标准库中的run函数。

<pre><code>
run { println(42) }
</code></pre>

一方面，这样的写法可以实现属性的懒加载（使用时赋值），同时，如果我们在一个UI的setup函数内构造很多UI控件，可以使用这样的写法控制局部临时变量的作用域。我们在开发过程中命名空间是非常宝贵的，但是为了增加可读性，我们希望尽可能的给变量一个有含义的名字。

<pre><code>
class View {

    fun createSubviews() {
        addSubviews({
            val textView = TextView()
            textView.text = "hello"
            textView
        }())

        addSubviews({
            val textView = TextView()
            textView.text = "world"
            textView.backgroundColor = Color.red
            textView
        }())
    }
}
</code></pre>

在不支持这样的语法的语言中，有的时候，我们会看到if(true) {}这样的写法，是想达到同样的目的，但是，这样写好么？

在介绍Lambdas时候的例子中的maxBy中的Lambdas是一个简写版本：

<pre><code>
val people = listOf(Person("Leo", 35), Person("Lucy", 28))
val oldestPerson = people.maxBy { it.age }
</code></pre>

如果我们不使用简介版本，可以这样改写：

<pre><code>
people.maxBy({ p: Person -> p.age })
</code></pre>

这样代码显得有一些冗长，太多的标点符号使得可读性差，且书写麻烦。我们可以简化它，与Groovy一样，当函数的入参中最后一个参数是lambda 表达式的时候，我们可以将其移到括号外。

<pre><code>
people.maxBy() { p: Person -> p.age }
</code></pre>

而我们当前这个例子中，lambda实际上是maxBy函数的唯一参数，因此我们此时可以省略掉小括号：

<pre><code>
people.maxBy { p: Person -> p.age }
</code></pre>

相对于第一个形式，最后的这个版本相对更简洁，且更佳容易理解，除了那个卡括号以外，这行代码看上去就像是一句话。这里的一个限制是，只有参数列表中的最后一个lambda才可以被放置在括号外面。

例如集合类中的joinToString函数，joinToString接受两个参数，一个是分隔符，一个是解析规则的lambda表达式。这个函数的可以将集合内的对象转换成字符串并用分隔符间隔拼接起来，函数返回拼接好的字符串。下面的两种写法都可以，而第二种写法明显比第一种更佳明确，两个输入的参数在不同的位置，有明确的作用。

<pre><code>
val people = listOf(Person("leo", 35), Person("Lucy", 25))
val names = people.joinToString(separator = "", transform = { p: Person -> p.name })
println(names) // 打印 Leo Lucy
</code></pre>

<pre><code>
val names = people.joinToString(" ") { p: Person -> p.name }
</code></pre>

对于不熟悉这个函数的开发人员，会对这lambda 表达式的作用感到困惑，但是，一旦你熟悉了则会从代码的简洁中受益。

注：函数式风格的学习曲线很偏陡峭，即开始有一些困难，但是一旦越过高山，会发现提升了一大块，包括设计，编码质量等各个方面。毕竟在熟悉了面向对象后再熟悉函数式，两种思维相互正交提灵活运用，多维度解决问题，会受益终生。

如果List中的类型是确定的，即编译器可以推演出集合中对象的类型，我们可以省略掉lambda入参中p的类型的声明。

<pre><code>
people.maxBy { p -> p.age }

people.jsonToString(" ") { p -> p.name } // 如果不用 -> 来作为分割会更好，这两个字符都需要shift
</code></pre>

在初始化数组的时候，编译器已经知道people集合中存放的对象的类型是Person，因此，编译器编译的时候可以确定，lambda的唯一入参类型是Person，我们不需要再去手动指定。

如果people的初始化位置离调用处太远，造成代码可读性降低，我们可以为其添加显示的类型声明。或者有一个不熟悉这段代码的人，想你询问这个参数的类型时，我们再去增加显示的声明。因此我们可以用一个简单的规则，首先我们在编写代码的时候可以始终选择省略参数类型声明，当编译器无法预判出输入参数的类型，或者遇到上面的可读性问题时，我们再不齐类型声明。

而当lambda表达式只有唯一的一个入参的时候，我们也可以使用缺省的名称it来引用它。编译器仅当我们不指定入参的名称的时候，才会帮我们增加it的缺省名称。

<pre><code>
people.maxBy { it.age }
</code></pre>

注：虽然使用it作为缺省参数名非常方便简洁，但是我们不能滥用，所有的地方都使用it肯定是不合适的，当我们需要通过入参来表达代码逻辑的时候，或者很难通过上下文知道it的对象的类型或者意义的时候，请给它一个名字，帮助未来的自己和同伴减轻理解代码的负担。

如果我们把一个lambda表达式赋值给一个变量的时候，则编译器将无法通过上下文来判定表达式的入参的类型，因此这个时候，我们是肯定需要明确指定的。

<pre><code>
val getAge = { p: Person -> p.age } //编译器在这里，不能确定p的类型，因此，Person不可以省略。
people.maxBy(getAge)
</code></pre>

如果lambda内部包含多行代码，且最后一行是表达式，则表达式的结果会同时作为lambda的结果被return。

在函数式语言中，函数可以被当作值进行保存或者传递给其它函数，我们称这样的能力为高阶函数（Higher Order Function），而面向对象的实现中必须要定义一个类并构造类的实例来传递给函数。使用Lambdas可以更加简化这个过程，我们可以省略定义一个函数，而直接编写一个代码块并传递给被调用的函数。

在终端开发中，定义匿名内部类最多的场景就是绑定事件的处理到UI空间上，例如，给一个UI上的按钮增加点击事件的处理逻辑。

<pre><code>
//in Java 1.4
btn.setOnClickListener(new OnClickListener() {
    @Override
    public void onClick(View v) {
        // 调用业务逻辑接口
    }
});

</code></pre>

上面的代码中，需要显示的定义一个匿名类，需要显示的构造这个类，并将类的实例传入setOnClickListener函数中，在客户端开发中，我们会有非常多的类似的事件需要进行绑定。而Kotlin中，我们可以将代码简化到极致。

<pre><code>
btn.setOnClickListener({ /*调用业务逻辑接口*/ })

//或者更加简介的形式

btn.setOnClickListener { /*调用业务逻辑接口*/ }
</code></pre>

第二种写法是很多支持函数式语言的特定，当函数入参的最后一个值是一个函数类型时，可以在括号外定义。第二种写法可读性更加高，我们可以很自然的理解为，当被点击的时候，执行{} 代码块内的逻辑。

#### lambdas 的变量的引用

当我们定义内部匿名类的时候，匿名类内的函数可以直接引用到宿主类的成员变量，在lambda中同样可以。在函数内使用lambda，表达式内同样可以使用lambda声明之前常见的函数内变量。

我们来看一个printErrors函数，输入一个列表集合，并制定打印error时使用的前缀。我们在函数内给forEach函数输入一个lambda，在lambda的实现内引用函数的prefix参数。

<pre><code>
fun printErrors(errors: List<String>, prefix: String) {
    errors.forEach {
        println("$prefix: $it")
    }
}

val errors = listOf("404 Not Found", "500 Server error")
printErrors(errors, "Error:")
</code></pre>

与java不同的是Kotlin允许我们在lambda中读写非final的变量， 

### 高阶函数

高阶函数是指可以把函数通过值传递给其它函数，而lambdas是高阶函数的一个简化版本。

函数式编程范式（规范模式）中一个很重要的概念就是高阶函数。我们通过把程序分为低层次逻辑和高阶函数来组织程序，我们用低层次的函数来实现逻辑框架和流程，并通过开发者实现具体的高阶函数作为参数传入框架来调整框架和流程的运作方式。而面向对象编程范式则是通过将状态与处理状态的逻辑封装成对象，通过命令式的风格来组织业务逻辑，典型的命令式风格是我们常用的for循环，通过初始一个初始状态，然后每次迭代的时候，都执行循环提中的一系列命令，（代码）

下面我们分别用函数式和面向对象两种范式实现过滤和统计功能，我们假设有一组关于员工信息的数据并存放在ArrayList中，我们需要统计数据中所有35岁以上员工的平均工资。

<pre><code>
//Java
class People {
    //为了简介，此处定义public域变量（field）
    public int age;
    public double salary;
}

class PeopleManager {
    public double catulateAverageSalaryOfMinAge(int age, List&lt;People&gt; peoples) {
        double totalSalary = 0;
        int count = 0;
        for(int i = 0; i &lt; peoples.size(); i++) {
            if( peoples.get(i).age >= 35) {
                totalSalary += peoples.get(i).salary;
                count++;
            }
        }

        return totalSalary / count;
    }
}
</code></pre>

而函数式风格的实现为下面的代码：

<pre><code>
data class People(var age: Int, var salary: Double)

val peoples = listOf(...)

val salarys = peoples.filter { it.age > 35 }.map { People::salary } //People::salary高阶函数

val averageSalary = salarys.reduce { total, salary -> total + salary } / salarys.size()

</code></pre>

我们可以把代码想成 拆封（unwrap） > 处理（process） > 封装（wrap） 的处理流程，函数式编程中提倡使用有限的几个核心的数据模型来封装数据，通过丰富的处理函数来实现对数据的处理。而面向对象则提倡为每一个数据定义一个类，因此面向对象中会有非常多的数据实体类，并将对此数据类型的操作封装到类中。在函数式开发中，我们会更多的使用map，list等核心数据模型来保存数据，而为每种数据模型定义丰富的函数来进行处理。

我们首先获得people集合实例，首先对数据进行过滤，之后我们对数据进行unwrap处理，我们需要提取出所有年龄大于35岁的人的工资的数组，因此，我们链式调用filter函数和map函数将数据拆封成只包含工资信息的数组。完成unwrap流程后，我们将进入处理过程，为了计算平均工资，我们需要求得数组中所有工资的综合，然后除以数组的个数来求得平均工资，因此我们对数据集的处理调用reduce函数，将数组的数据项聚合转换成综合，最终与salarys数组的总数相处得到。

这里对数据集的处理通过过滤（filter）、映射（map）和聚合（reduce）来完成数据处理的低层次框架，开发人员通过高阶函数或lambdas表达式传入过滤条件、映射规则和聚合规则来改变低层次函数的行为。了解基于Hadoop大数据处理的读者应该对map-reduce数据处理框架非常了解。

使用kotlin开发的代码比面向对象版本少了for循环和代码嵌套，取而代之的是命令式低层次函数和lambdas来完成，细心的读者应该会发现，我们对计算步骤的描述与函数式版本的代码非常吻合，但是从面向对象版本中，并没有清晰的体现。

### 


## 处理集合类

函数式风格给操作处理集合类带来了非常好的支持，简化代码的同时增加可读性。我们会介绍一些Kotlin标准库中的集合类处理换书，先从上面的出现的函数开始
## 函数式响应编程 FRP

## 函数式编程与面向接口编程结合
