#  Kotlin函数式编程

面向对象设计是以类为单位，将一组状态属性和处理状态的逻辑封装在一个单一的类中，由于这样的封装，因此类内的成员函数是可以共享类内不的所有成员变量的，即共享和共同管理状态。而如果类成员变量是构造时传入的外部对象，这个对象就可能在多处被修改，但是由于是引用，人和地方对这个对象的修改，都会影响全局而造成我们类中的函数的行为不可预估。这就是函数式编程中提到的副作用。

<pre><code>
var tokenItems = mutableListOf<String>()
class TokenManager(var tokenItems: List<String>)

fun TokenManager.dump() { items.forEach { println("$it")} } // 为类增加成员函数，扩展类

val tokenManager = TokenManager(tokenItems)

tokenManager.dump() //没有内容被打印

tokenItems.add("token1")

tokenManager.dump() //打印Token1
</code></pre>

TokenManager中的成员函数dump的行为依赖函数外部的类成员属性的状态，因此，单从dump函数的逻辑，我们是没办法判断出dump的行为。开发人员单看dump函数式不可能知道，是否还有别的地方修改了items里面的数据。

纯函数机遇不可变属性，对象拷贝和无状态函数来消除副作用，从而达到易测试，且线程安全。

<pre><code>
fun dumpAllToken(val items: List<String>) {
    items.forEach { println(it) }
}

var tokenItems = mutableListOf<String>("hello")

dumpAllToken(listOf(tokenItems))

</code></pre>

## 基本概念

### Top-Level 函数

Kotlin语言中，package下直接定义的函数为Top-Level函数，Package下可以直接通过函数名对Top-Level函数进行调用。上面代码中的dumpAllToken函数就是一个Top-Level函数。

## lambdas 表达式

lambdas指的是将一小段代码作为闭包传入到其它函数。我们可以将我们的逻辑，通过lambdas的形式注入到库函数中，而且Kotlin的标准类库大量使用lambdas来实现对标准库的扩展。Kotlin还支持Lambdas with recevier特性，Receiver就是lambdas执行的目标对象，我们可以理解为调用Receiver对象的一个扩展的类成员方法。同时lambdas还可以赋值给变量，在开发过程中，保存或者传递lambdas给函数会非常频繁。在Java的早期版本，我们必须要通过内部类来封装这些轻量的代码块，而lambdas实现同样的作用且代码会更加简介。

在函数式语言中，函数可以被当作值进行保存或者传递给其它函数，我们称这样的能力为高阶函数（Higher Order Function），代替面向对象中必须要定义一个类并构造类的实例来传递给函数。使用Lambdas可以更加简化这个过程，我们可以省略定义一个函数，而直接编写一个代码块并传递给被调用的函数。

在过去，定义匿名内部类最多的场景就是绑定事件的处理到UI空间上，例如，给一个UI上的按钮增加点击事件的处理逻辑。

<pre><code>
//in Java 1.4
btn.setOnClickListener(new OnClickListener() {
    @Override
    public void onClick(View v) {
        // 调用业务逻辑接口
    }
});

</code></pre>

上面的代码中，需要显示的定义一个匿名类，需要显示的构造这个类，并将类的实例传入setOnClickListener函数中，在客户端开发中，我们会有非常多的类似的事件需要进行绑定。而Kotlin中，我们可以将代码简化到极致。

<pre><code>
btn.setOnClickListener({ /*调用业务逻辑接口*/ })

//或者更加简介的形式

btn.setOnClickListener { /*调用业务逻辑接口*/ }
</code></pre>

第二种写法是很多支持函数式语言的特定，当函数入参的最后一个值是一个函数类型时，可以在括号外定义。第二种写法可读性更加高，我们可以很自然的理解为，当被点击的时候，执行{} 代码块内的逻辑。

## 高阶函数的运用

函数式编程范式（规范模式）中一个很重要的概念就是高阶函数。我们通过把程序分为低层次逻辑和高阶函数来组织程序，我们用低层次的函数来实现逻辑框架和流程，并通过开发者实现具体的高阶函数作为参数传入框架来调整框架和流程的运作方式。而面向对象编程范式则是通过将状态与处理状态的逻辑封装成对象，通过命令式的风格来组织业务逻辑，典型的命令式风格是我们常用的for循环，通过初始一个初始状态，然后每次迭代的时候，都执行循环提中的一系列命令，（代码）

下面我们分别用函数式和面向对象两种范式实现过滤和统计功能，我们假设有一组关于员工信息的数据并存放在ArrayList中，我们需要统计数据中所有35岁以上员工的平均工资。

<pre><code>
//Java
class People {
    //为了简介，此处定义public域变量（field）
    public int age;
    public double salary;
}

class PeopleManager {
    public double catulateAverageSalaryOfMinAge(int age, List&lt;People&gt; peoples) {
        double totalSalary = 0;
        int count = 0;
        for(int i = 0; i &lt; peoples.size(); i++) {
            if( peoples.get(i).age >= 35) {
                totalSalary += peoples.get(i).salary;
                count++;
            }
        }

        return totalSalary / count;
    }
}
</code></pre>

而函数式风格的实现为下面的代码：

<pre><code>
data class People(var age: Int, var salary: Double)

val peoples = listOf(...)

val salarys = peoples.filter { it.age > 35 }.map { People::salary }

val averageSalary = salarys.reduce { total, salary -> total + salary } / salarys.size()

</code></pre>

我们可以把代码想成 拆封（unwrap） > 处理（process） > 封装（wrap） 的处理流程，函数式编程中提倡使用有限的几个核心的数据模型来封装数据，通过丰富的处理函数来实现对数据的处理。而面向对象则提倡为每一个数据定义一个类，因此面向对象中会有非常多的数据实体类，并将对此数据类型的操作封装到类中。在函数式开发中，我们会更多的使用map，list等核心数据模型来保存数据，而为每种数据模型定义丰富的函数来进行处理。

我们首先获得people集合实例，首先对数据进行过滤，之后我们对数据进行unwrap处理，我们需要提取出所有年龄大于35岁的人的工资的数组，因此，我们链式调用filter函数和map函数将数据拆封成只包含工资信息的数组。完成unwrap流程后，我们将进入处理过程，为了计算平均工资，我们需要求得数组中所有工资的综合，然后除以数组的个数来求得平均工资，因此我们对数据集的处理调用reduce函数，将数组的数据项聚合转换成综合，最终与salarys数组的总数相处得到。

这里对数据集的处理通过过滤（filter）、映射（map）和聚合（reduce）来完成数据处理的低层次框架，开发人员通过高阶函数或lambdas表达式传入过滤条件、映射规则和聚合规则来改变低层次函数的行为。了解基于Hadoop大数据处理的读者应该对map-reduce数据处理框架非常了解。

使用kotlin开发的代码比面向对象版本少了for循环和代码嵌套，取而代之的是命令式低层次函数和lambdas来完成，细心的读者应该会发现，我们对计算步骤的描述与函数式版本的代码非常吻合，但是从面向对象版本中，并没有清晰的体现。

## 处理集合类

## 函数式响应编程 FRP

## 函数式编程与面向接口编程结合
