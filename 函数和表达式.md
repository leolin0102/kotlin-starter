#  Kotlin函数式编程

面向对象设计是以类为单位，将一组状态属性和处理状态的逻辑封装在一个单一的类中，由于这样的封装，因此类内的成员函数是可以共享类内不的所有成员变量的，即共享和共同管理状态。而如果类成员变量是构造时传入的外部对象，这个对象就可能在多处被修改，但是由于是引用，人和地方对这个对象的修改，都会影响全局而造成我们类中的函数的行为不可预估。这就是函数式编程中提到的副作用。

<pre><code>
var tokenItems = mutableListOf<String>()
class TokenManager(var tokenItems: List<String>)

fun TokenManager.dump() { items.forEach { println("$it")} } // 为类增加成员函数，扩展类

val tokenManager = TokenManager(tokenItems)

tokenManager.dump() //没有内容被打印

tokenItems.add("token1")

tokenManager.dump() //打印Token1
</code></pre>

TokenManager中的成员函数dump的行为依赖函数外部的类成员属性的状态，因此，单从dump函数的逻辑，我们是没办法判断出dump的行为。开发人员单看dump函数式不可能知道，是否还有别的地方修改了items里面的数据。

纯函数机遇不可变属性，对象拷贝和无状态函数来消除副作用，从而达到易测试，且线程安全。

<pre><code>
fun dumpAllToken(val items: List<String>) {
    items.forEach { println(it) }
}

var tokenItems = mutableListOf<String>("hello")

dumpAllToken(listOf(tokenItems))

</code></pre>

## 基本概念

### Top-Level 函数

Kotlin语言中，package下直接定义的函数为Top-Level函数，Package下可以直接通过函数名对Top-Level函数进行调用。上面代码中的dumpAllToken函数就是一个Top-Level函数。

## Lambdas 表达式 和 高阶函数（Higher Order Function）

### Lambdas

lambdas指的是将一小段代码作为闭包传入到其它函数，也可以赋值给变量来保存。我们可以将我们的逻辑，通过lambdas的形式注入到库函数中，而且Kotlin的标准类库大量使用lambdas来实现对标准库的扩展。Kotlin还支持Lambdas with recevier特性，Receiver就是lambdas执行的目标对象，我们可以理解为调用Receiver对象的一个扩展的类成员方法。同时lambdas还可以赋值给变量，在开发过程中，保存或者传递lambdas给函数会非常频繁。在Java的早期版本，我们必须要通过内部类来封装这些轻量的代码块，而lambdas实现同样的作用且代码会更加简介。

#### Lambdas 与 collections

我们对我们的代码进行设计，和重构的一个一个很重要的目标就是消除代码重复（冗余）。在Kotlin的函数式标准库为我们提供了一套函数来支持以一种通用的模式来操作集合，我们通过Lambdas的形式将我们的代码注入到库函数中来让我们的代码和标准库合二为一来实现最终的目标。

我们分用函数式和非函数式两种风格实现找到一组人中的最大年纪,并将这个人的纪录打印出来。

首先定义一个People类来代表人

<pre><code>
data class Person(val name: String, val age: Int)

fun printTheOldestAge(people: List&lt;Person&gt;) {
    var maxAge = 0
    var theOldest: Person? = null
    for (person in people) {
        if (person.age > maxAge) {
            maxAge = person.age
            theOldest = person
        }
    }
    println("年龄最大的人是： $person ")
}

// function version

val people = listOf(Person("Leo", 35), Person("Lucy", 28))

val theOldestPerson = people.maxBy { it.age }

println("年龄最大的人是： $theOldestPerson ")

</code></pre>

#### lambdas 语法

上面提到lambdas可以赋值给变量，来实现多处重用，但是，更多的时候是在定义的同时传递给函数。

<pre><code>
// 一个lambdas
{ x: Int, y: Int -> x + y}
</code></pre>

lambdas中的代码必须使用打括号“{}”来包含，括号内最开始是lambdas的参数列表，使用->来将参数列表和代码部分分开。我们可以理解，lambdas是在“{}”同时完成了函数声明和实现，类型为{x:Int, y:Int} -> Int,我们可以将这个lambds传给任何以这个类型为入参的函数。

<pre><code>
fun process(items: List&lt;Int&gt;, catulator:(Int, Int) -> Int) {

}

process(items) { x: Int, y: Int -> x + y }

</code></pre>

可以将lambdas直接赋值给一个变量。

<pre><code>

val sum = { x: Int, y: Int -> x + y }

println(sum(1, 2))// 打印输出3

</code></pre>

也可以通过后跟小括号“()”来直接调用执行一个表达式。

<pre><code>
&gt;&gt;&gt; { println(42) }()

42
</code></pre>

这样执行一个Lambdas虽然解释的通，但是会让我们感觉有点奇怪。一种可读性更高的写法是使用Kotlin标准库中的run函数。

<pre><code>
run { println(42) }
</code></pre>

一方面，这样的写法可以实现属性的懒加载（使用时赋值），同时，如果我们在一个UI的setup函数内构造很多UI控件，可以使用这样的写法控制局部临时变量的作用域。我们在开发过程中命名空间是非常宝贵的，但是为了增加可读性，我们希望尽可能的给变量一个有含义的名字。

<pre><code>
class View {

    fun createSubviews() {
        addSubviews({
            val textView = TextView()
            textView.text = "hello"
            textView
        }())

        addSubviews({
            val textView = TextView()
            textView.text = "world"
            textView.backgroundColor = Color.red
            textView
        }())
    }
}
</code></pre>

在不支持这样的语法的语言中，有的时候，我们会看到if(true) {}这样的写法，是想达到同样的目的，但是，这样写好么？

在介绍Lambdas时候的例子中的maxBy中的Lambdas是一个简写版本：

<pre><code>
val people = listOf(Person("Leo", 35), Person("Lucy", 28))
val oldestPerson = people.maxBy { it.age }
</code></pre>

如果我们不使用简介版本，可以这样改写：

<pre><code>
people.maxBy({ p: Person -> p.age })
</code></pre>

这样代码显得有一些冗长，太多的标点符号使得可读性差，且书写麻烦。

在函数式语言中，函数可以被当作值进行保存或者传递给其它函数，我们称这样的能力为高阶函数（Higher Order Function），而面向对象的实现中必须要定义一个类并构造类的实例来传递给函数。使用Lambdas可以更加简化这个过程，我们可以省略定义一个函数，而直接编写一个代码块并传递给被调用的函数。

在终端开发中，定义匿名内部类最多的场景就是绑定事件的处理到UI空间上，例如，给一个UI上的按钮增加点击事件的处理逻辑。

<pre><code>
//in Java 1.4
btn.setOnClickListener(new OnClickListener() {
    @Override
    public void onClick(View v) {
        // 调用业务逻辑接口
    }
});

</code></pre>

上面的代码中，需要显示的定义一个匿名类，需要显示的构造这个类，并将类的实例传入setOnClickListener函数中，在客户端开发中，我们会有非常多的类似的事件需要进行绑定。而Kotlin中，我们可以将代码简化到极致。

<pre><code>
btn.setOnClickListener({ /*调用业务逻辑接口*/ })

//或者更加简介的形式

btn.setOnClickListener { /*调用业务逻辑接口*/ }
</code></pre>

第二种写法是很多支持函数式语言的特定，当函数入参的最后一个值是一个函数类型时，可以在括号外定义。第二种写法可读性更加高，我们可以很自然的理解为，当被点击的时候，执行{} 代码块内的逻辑。

### 高阶函数

高阶函数是指可以把函数通过值传递给其它函数，而lambdas是高阶函数的一个简化版本。

函数式编程范式（规范模式）中一个很重要的概念就是高阶函数。我们通过把程序分为低层次逻辑和高阶函数来组织程序，我们用低层次的函数来实现逻辑框架和流程，并通过开发者实现具体的高阶函数作为参数传入框架来调整框架和流程的运作方式。而面向对象编程范式则是通过将状态与处理状态的逻辑封装成对象，通过命令式的风格来组织业务逻辑，典型的命令式风格是我们常用的for循环，通过初始一个初始状态，然后每次迭代的时候，都执行循环提中的一系列命令，（代码）

下面我们分别用函数式和面向对象两种范式实现过滤和统计功能，我们假设有一组关于员工信息的数据并存放在ArrayList中，我们需要统计数据中所有35岁以上员工的平均工资。

<pre><code>
//Java
class People {
    //为了简介，此处定义public域变量（field）
    public int age;
    public double salary;
}

class PeopleManager {
    public double catulateAverageSalaryOfMinAge(int age, List&lt;People&gt; peoples) {
        double totalSalary = 0;
        int count = 0;
        for(int i = 0; i &lt; peoples.size(); i++) {
            if( peoples.get(i).age >= 35) {
                totalSalary += peoples.get(i).salary;
                count++;
            }
        }

        return totalSalary / count;
    }
}
</code></pre>

而函数式风格的实现为下面的代码：

<pre><code>
data class People(var age: Int, var salary: Double)

val peoples = listOf(...)

val salarys = peoples.filter { it.age > 35 }.map { People::salary } //People::salary高阶函数

val averageSalary = salarys.reduce { total, salary -> total + salary } / salarys.size()

</code></pre>

我们可以把代码想成 拆封（unwrap） > 处理（process） > 封装（wrap） 的处理流程，函数式编程中提倡使用有限的几个核心的数据模型来封装数据，通过丰富的处理函数来实现对数据的处理。而面向对象则提倡为每一个数据定义一个类，因此面向对象中会有非常多的数据实体类，并将对此数据类型的操作封装到类中。在函数式开发中，我们会更多的使用map，list等核心数据模型来保存数据，而为每种数据模型定义丰富的函数来进行处理。

我们首先获得people集合实例，首先对数据进行过滤，之后我们对数据进行unwrap处理，我们需要提取出所有年龄大于35岁的人的工资的数组，因此，我们链式调用filter函数和map函数将数据拆封成只包含工资信息的数组。完成unwrap流程后，我们将进入处理过程，为了计算平均工资，我们需要求得数组中所有工资的综合，然后除以数组的个数来求得平均工资，因此我们对数据集的处理调用reduce函数，将数组的数据项聚合转换成综合，最终与salarys数组的总数相处得到。

这里对数据集的处理通过过滤（filter）、映射（map）和聚合（reduce）来完成数据处理的低层次框架，开发人员通过高阶函数或lambdas表达式传入过滤条件、映射规则和聚合规则来改变低层次函数的行为。了解基于Hadoop大数据处理的读者应该对map-reduce数据处理框架非常了解。

使用kotlin开发的代码比面向对象版本少了for循环和代码嵌套，取而代之的是命令式低层次函数和lambdas来完成，细心的读者应该会发现，我们对计算步骤的描述与函数式版本的代码非常吻合，但是从面向对象版本中，并没有清晰的体现。

### 


## 处理集合类

函数式风格给操作处理集合类带来了非常好的支持，简化代码的同时增加可读性。我们会介绍一些Kotlin标准库中的集合类处理换书，先从上面的出现的函数开始
## 函数式响应编程 FRP

## 函数式编程与面向接口编程结合
