# 函数式响应编程 FRP

函数式风格的函数通过避免对状态做更改来消除副作用，在某些情况下，应用程序需要相应动态变量和状态的改变。例如我们需要在从服务器请求到新数据后刷新UI。我们如何在保持函数基于不可变和无状态的原则下同时实现对状态的维护？

响应式编程通过间接的监听和捕获状态的改变来出发响应函数进行处理。而FRP提供一种通过将函数式变成和响应式变成相结合的途径使得我们在既以写出函数式风格的代码（易于测试，无副作用）又可以处理好状态的改变。响应式编程通过特定的数据类型来出发响应，这种数据类型被叫做时间流或者事件流。

本章会结合响应式函数框架RxJava来实现一个时间管理的小程序，以此向大家介绍如何使用FRP将函数式编程运用到实际项目中。                                

## RxJava

RxJava是一套代码库通过对状态的观察产生异步的或者顺序的事件流，并传递给订阅者进行相应来完成逻辑。状态和数据的改变经由事件流流向处理函数，函数紧紧根据接收到的事件进行响应，并将结果通知到状态和数据对象。通过FRP可以将状态和双射函数进行组合

### 状态

很难定义状态，通过一个例子我们来认识一下状态。

当你启动笔记本后，开始一切都很好，但是当你使用了一段时间后几天甚至几周都不关机的时候，你发现界面的响应开始变慢，时不时的会有卡顿发生。笔记本中的硬件和刚开机时一样没有改变，而因此性能变化的原因就是状态的改变。当你重新启动机器后，一切又恢复正常。

笔记本当前的账号、保存在内存中的数据、磁盘中保存的文件、响应用户输入保存的临时变量和从云端同步下来的所有数据一起组成了你笔记本的状态。

伴随着不对对一个产品深入的开发，一次一次的迭代强化，管理好状态，尤其是在多线程异步组件之间安全的共享状态以及变更将会成为一个非常有挑战的任务。函数式风格的代码解决了外部状态改变对其的影响，另你的函数的行为更加的可预测简化了大部分代码实现的复杂度同时提升了可测试性，因为测试代码仅针对输入的参数进行测试就可以覆盖函数的所有代码。与此同时RxJava框架通过顺序事件流数据结构来传播状态的改变从而提供通用的方法来实现多线程间安全的共享状态。因此FRP在实现面向对象中的很多设计模式提供的可扩展性和代码可重用能力的同时，使得我们不用去花很多精力构造对象并维护依赖关系。

### 命令式编程 （Imperative programming）

面向对象使用命令式编程，命令式编程是一种编程范式通过执行语句不断改变程序的状态。有点像人类和自己的宠物在对话。“斑斑，转个圈。躺下。” 你使用命令语句来告诉app合适如何做某件事。


命令式代码更接近于计算机理解代码的方式。所有CPU都是顺序加载和执行简单的命令的。问题在于当人类用同样的方式编写非常复杂、异步运行的命令式代码时就会非常容易出错，尤其是在设计多线程异步共享状态的时候。

<pre><code>
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setupUI()
        connectUIControls()
        createDataSource()
        listenForChanges()
    }
</code></pre>

从代码中是没办法明确知道这几个函数调用的结果是什么，因为这些方法都根据类成员的状态来控制自身行为并修改类成员变量。在这个类中，几个函数实际上是在共享状态，同样由于这样的实现，对这几个看似不相关的函数的调用顺序进行调整也会影响onCreate最终的结果，即使我们没有改变过任何一个方法的实现。

我们曾经对项目中IM通信层进行重构，当时面临的最大的一个问题就是之前的代码对链接状态的控制被分散到了许多的lambda回调用中，任何一个你不知道的代码块中都可能会对一个类全局的状态进行变更，在网络好的情况下一切正常，由于开发的时候工程师紧紧考虑固定地点wifi的情况下（开发的时候不可能一遍拿着手机各处跑，一遍写代码）因此在网络好的时候，状态从断开链接迁移到了链接中，从连接中迁移到了链接成功，从连接成功状态迁移到开始同步数据，最终到巡航状态长链接通道使程序在线接受所有即时消息，而每个环节都是一个lambda，lambda通过改变状态来控制下一个lambda的行为，以此类推。

我们想像一下如果在网络状态频繁复杂变化的情况下，不断的超时，断网触发重新连接，同时在上面的任何一个状态下都可能发生链接中断，这个时候如果没有确保同时只有一个线程进行连接，程序的表现就不像是被设计好的逻辑代码控制，道像是靠一个概率模型来控制的。如果我们继续尝试在各个地方重置状态希望以此能修复问题，结果将必定是徒劳的，因为代码中的副作用依然存在。加之没有使用aop的方式输出必要的日志，因此，重构前负责这个模块的工程师分析了大量的日志，和进行过非常多的测试，但是每次能给出的结论只有连不上，这是结果，用户是不会接受这样的反馈的。


### 陈述性代码

陈述性代码像是这样表达一个逻辑“把这个集合中第一个满足年龄大于25岁的Person的name作为结果返回”，翻译成代码：

<pre><code>
data class Person(val name: String, val age: Int)

val people = listOf(Person("Leo", 35), Person("Lucy", 25))

// 把这个集合中第一个满足年龄大于25岁的Person的name作为结果返回
val result = people.find { it.age &gt; 25 }.map { it.name }


println(result)

// 输出 Leo
</code></pre>

而命令式风格的描述则显得有些凌乱“声明一个String类型的变量叫result，使用for 语句根据一个临时的变量i进行循环，知道i >= 集合的个数，每次循环里检测第i个对象的age属性判断是否大于25，如果大于25则将第i个对象的name赋值给result然后跳出for循环”

这个描述比陈述式风格的描述要长很多，同样，代码也会长很多。而且会增加很多缩进。

<pre><code>
// Java

//声明一个String类型的变量叫result，使用for 语句根据一个临时的变量i进行循环，知道i >= 集合的个数，每次循环里检测第i个对象的age属性判断是否大于25，如果大于25则将第i个对象的name赋值给result然后跳出for循环
String result = "";
for (int i = 0; i &lt; people.size(): i++) {
    Person person = people.get(i);
    if (person.age &gt; 25) {
        result = person.name
        break;
    }
}
</code></pre>

RxJava帮助我们在多线程环境下维护状态的同步即同一时刻仅有一个线程可以更新状态，与此同时因状态改变产生的事件响应的顺序与状态改变的顺序一致，即不发生后产生的状态改变的事件响应被提前执行而造成状态混乱。

### RxJava的响应体系

响应式系统具备一下特点：

- 迅速响应：App的UI应该永远反应应用程序最新的状态。
- 弹性：每一个事件的响应都是功能单一的相互隔离的，并且可以实现灵活的错误恢复逻辑。（这里应用弹簧的恢复特性，想象我们给弹簧压力造成其形变后，每当压力小时的时候，弹簧都会恢复原样）
- 伸缩性：响应框架实现很多基础特性例如lazy 数据拉取、事件截流、资源共享等特性，利用好这些特性我们可以确保我们的代码和所需要的资源紧紧在需要的时候才会被运行或者产生。
- 消息驱动：使用基于消息通信机制对组件进行集成可以帮助我们提高代码的重用能力、隔离性、以及类实现与生命周期控制的解偶合。
注意：弹到弹簧的特性，可以考虑一下好的弹簧床垫与次品的区别，就是好的弹簧床垫的每一个弹簧都。

### rx.Observable

Observable代表一个有序的数据流。你会一直使用这个抽象类来进行编程。因为数据流可以长时间不停的产生新的数据，因为可以将其看作事件流。通过对其调用subscribe函数来订阅数据的改变。日常有很多时间流的例子： 

















首先创建一个Grandle管理的Android项目TimeMachine，这个小程序的目标是记录日常的事件分配，把日常工作分为专注，积累和挑战三种不同的模式，并记录我们日常完成这些任务所分配的时间我们会让用户每天都可以看到以年、月、周和天为单位的数据聚合统计。