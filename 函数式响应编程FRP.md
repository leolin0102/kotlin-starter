# 函数式响应编程 FRP

函数式风格的函数通过避免对状态做更改来消除副作用，在某些情况下，应用程序需要相应动态变量和状态的改变。例如我们需要在从服务器请求到新数据后刷新UI。我们如何在保持函数基于不可变和无状态的原则下同时实现对状态的维护？

响应式编程通过间接的监听和捕获状态的改变来出发响应函数进行处理。而FRP提供一种通过将函数式变成和响应式变成相结合的途径使得我们在既以写出函数式风格的代码（易于测试，无副作用）又可以处理好状态的改变。响应式编程通过特定的数据类型来出发响应，这种数据类型被叫做时间流或者事件流。

本章会结合响应式函数框架RxJava来实现一个时间管理的小程序，以此向大家介绍如何使用FRP将函数式编程运用到实际项目中。                                

## RxJava

RxJava是一套代码库通过对状态的观察产生异步的或者顺序的事件流，并传递给订阅者进行相应来完成逻辑。状态和数据的改变经由事件流流向处理函数，函数紧紧根据接收到的事件进行响应，并将结果通知到状态和数据对象。通过FRP可以将状态和双射函数进行组合

### 状态

很难定义状态，通过一个例子我们来认识一下状态。

当你启动笔记本后，开始一切都很好，但是当你使用了一段时间后几天甚至几周都不关机的时候，你发现界面的响应开始变慢，时不时的会有卡顿发生。笔记本中的硬件和刚开机时一样没有改变，而因此性能变化的原因就是状态的改变。当你重新启动机器后，一切又恢复正常。

笔记本当前的账号、保存在内存中的数据、磁盘中保存的文件、响应用户输入保存的临时变量和从云端同步下来的所有数据一起组成了你笔记本的状态。

伴随着不对对一个产品深入的开发，一次一次的迭代强化，管理好状态，尤其是在多线程异步组件之间安全的共享状态以及变更将会成为一个非常有挑战的任务。函数式风格的代码解决了外部状态改变对其的影响，另你的函数的行为更加的可预测简化了大部分代码实现的复杂度同时提升了可测试性，因为测试代码仅针对输入的参数进行测试就可以覆盖函数的所有代码。与此同时RxJava框架通过顺序事件流数据结构来传播状态的改变从而提供通用的方法来实现多线程间安全的共享状态。因此FRP在实现面向对象中的很多设计模式提供的可扩展性和代码可重用能力的同时，使得我们不用去花很多精力构造对象并维护依赖关系。

### 命令式编程 （Imperative programming）

面向对象使用命令式编程，命令式编程是一种编程范式通过执行语句不断改变程序的状态。有点像人类和自己的宠物在对话。“斑斑，转个圈。躺下。” 你使用命令语句来告诉app合适如何做某件事。


命令式代码更接近于计算机理解代码的方式。所有CPU都是顺序加载和执行简单的命令的。问题在于当人类用同样的方式编写非常复杂、异步运行的命令式代码时就会非常容易出错，尤其是在设计多线程异步共享状态的时候。

<pre><code>

</code></pre>

我们曾经对项目中IM通信层进行重构，当时面临的最大的一个问题就是之前的代码对链接状态的控制被分散到了无数的lambda调用中，任何一个你不知道的代码块中都可能会对一个半全局的状态进行变更，在网络好的情况下一切正常，由于开发的时候工程师紧紧考虑一切正常的情况因此在网络好的时候，状态从断开链接迁移到了链接中，从连接中迁移到了链接成功，从连接成功状态迁移到开始同步数据，最终到巡航状态长链接通道使程序在线接受所有即时消息，而每个环节都是一个lambda，lambda通过改变状态来控制下一个lambda的行为，以此类推。

我们想像一下如果在网络状态频繁复杂变化的情况下，不断的超时，断网触发重新连接，同时在上面的任何一个状态下都可能发生链接中断，这个时候如果没有确保同时只有一个线程进行连接，程序的表现就不像是被设计好的逻辑代码控制，道像是靠一个概率模型来控制的。如果我们继续尝试在各个地方重制状态希望能修复问题将必定是徒劳的，因为代码中的副作用依然存在。加之没有使用sop的方式输出必要的日志，因此，重构前负责这个模块的工程师分析了无数的日志，和进行过非常多的测试，但是每次能给出的结论只有连不上但是实际上这是没有意义的。






















首先创建一个Grandle管理的Android项目TimeMachine，这个小程序的目标是记录日常的事件分配，把日常工作分为专注，积累和挑战三种不同的模式，并记录我们日常完成这些任务所分配的时间我们会让用户每天都可以看到以年、月、周和天为单位的数据聚合统计。