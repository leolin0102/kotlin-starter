#  OOP面向对象编程

## OOP设计原则

这小结我们会介绍几个面向对象基本的设计原则，这些原则是经过多年众多行业经营总结出来的基础的原则，他们就像物理学家们定义的物理公式一样，它们都如此的简单且优美，但却非常广泛的影响着我们编写的每一行代码。

通常，OOP方式的两种被指责的反模式是：
- 通过类将一种数据格式及其行为进行绑定，从而将状态封装在其内部进行维护是一种将问题隐藏起来而不是解决问题，因为可变状态会带来副作用。
- 面向对象偏向设计一个合理的类之间的继承关系来达到最大限度的代码重用和多态化，但是继承并不是最好的实现多态及代码高可重用的方式。

OOP通过SOLID和DDD这两大原则来解决上面的问题，SOLID中的每个字母都是一个原则的首字母,而DDD则是领域驱动设计(Domain-driven Design)的缩写，我们下面来一一向大家介绍。

### SOLID

SOLID包括如下五个原则

- 单一职责原则 （Single Responsibility Principle, SRP）
- 开闭原则 （The Open/Close Principle, OCP）
- 可被替换原则 （Liskov Substitution Principle, LSP）
- 接口分离原则 （Interface Segregation Principle, ISP)
- 依赖反转原则 （Dependency Inversion Principle, DIP)

这五个原则指导着我们设计的每一个接口，类以及我们如何对现有代码进行持续重构优化，从而达到最佳的代码可伸缩，可测试以及高可复用等目标。

#### 单一职责原则 （SRP）

单一原则要求每一个类都应该有唯一且明确的职责定义，对其职责的改变需要有明确的原因。

这个原则的定义是为了避免定义一个粗线条的超大类并负责多种角色的反模式，设想你刚加入一个公司接管一个项目，如果你没能对其代码完全掌控，那么原因是什么？很可能就是其中几个几千行的类。到你离开或者这个产品被放弃，可能这些类都无法被重构优化，只要这些怪兽类存在问题，我们就必须拼尽体力去不断查日志并加断点调试，猜问题可能出现在哪里。

形成超大类可能有很多原因，一个核心的问题在于OOP将数据结构以及行为封装在一起，问题在于这样对数据接口及其行为的封装不仅仅弱化了组合、聚合在代码灵活可复用的作用，并且将问题隐藏在其内部。最终结果是面向对象代码中经常包括很多数据结构类并带有非常多的方法。

有的项目里会有很多叫Service、Manager、Helper的类，除非团队大家对这些类的角色、职责有非常明确且一致的定义，否则这些类极有可能会生长为巨兽级别的类，因为似乎什么方法都可以放到里面，本来Manager就是应该做很多事情的么。

#### 开闭原则 （OCP）

开闭的意思是对外开放扩展性，而封闭变化，开闭原则就是指我们设计的类应允许外部可以容易的对其进行扩展，同时对类自身的改动也不会影响到外部的其他类，反之外部类的任何改动也不应该影响到这个类的内部。

对已有的类的改动应该仅仅因为这个类自身的bug或者因为需求的改变对其做的调整，这个OCP中的封闭原则。开放的概念则是允许以重用代码的目的对一个类进行继承，或者以注入接口实现的方式对类本身进行扩展。然而通过以继承的形式实现代码重用往往会增加其实现的复杂度，因为很多时候要想确保一个类的方法可以安全的被重载需要基类在设计时考虑更多的因素，尤其是对状态的控制，想想面向对象编程的思路是允许代码以命令行的方式运行，通过代码更改可变量从而实现用状态控制对象行为。我们稍后介绍的LSP原则对继承。

这个思想其实可以延伸一下，当我们设计的不仅仅是一个类而是一个组件，open／close 原则同样也是需要被考虑的，组件需要对外提供必要的接口隔离自身的变化并尽量确保接口的向下兼容性，而对外提供良好的可扩展性同样需要定义清晰的接口供外部实现并注入回组件实现扩展型。有一个比较简单的原则就是组件的扩展性应该一视同仁，即自己如何扩展这个功能，那么外界也应该可以用相同的方式实现同样的功能。例如实现一个主题导航组件，那么导航组件自己提供的默认导航项的实现和创建方式，应该与业务逻辑添加其它导航项的方式保持一致。这个原则将避免组件自己有上帝模式，或者是自己的个性使之可以尽可能多的满足更多的需求，且这个一致性就像是乐高玩具一样，由有限种类的零件可以灵活组合出无限中可能。

#### 可被替换原则 （LSP）

可被替换原则指程序中的任何一个对象应该可以被人和一个自身的子类的对象替换而不会影响整个程序的稳定性和正确性。

Kotlin语言默认所有方法和属性不可以被重载的目的就是确保所有的重载行为都需要是被设计的，在设计类的时候就应该充分考虑哪些方法可以被安全的重载。要求这样的原因就是要确保LSP原则。要做到这点需要保证父类对外支持的能力其子类必须同样满足，子类不能有任何的假设，子类必须接受所有父类声明接受的属性，并初始化自己及基类的状态。而这些原则是无法通过语法和静态检测来保证的，必须是在设计环节被考虑进来。