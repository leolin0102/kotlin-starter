#  OOP面向对象编程

## OOP设计原则

这小结我们会介绍几个面向对象基本的设计原则，这些原则是经过多年众多行业经营总结出来的基础的原则，他们就像物理学家们定义的物理公式一样，它们都如此的简单且优美，但却非常广泛的影响着我们编写的每一行代码。

通常，OOP方式的两种被指责的反模式是：
- 通过类将一种数据格式及其行为进行绑定，从而将状态封装在其内部进行维护是一种将问题隐藏起来而不是解决问题，因为可变状态会带来副作用。
- 面向对象偏向设计一个合理的类之间的继承关系来达到最大限度的代码重用和多态化，但是继承并不是最好的实现多态及代码高可重用的方式。

OOP通过SOLID和DDD这两大原则来解决上面的问题，SOLID中的每个字母都是一个原则的首字母,而DDD则是领域驱动设计(Domain-driven Design)的缩写，我们下面来一一向大家介绍。

### SOLID

SOLID包括如下五个原则

- 单一职责原则 （Single Responsibility Principle, SRP）
- 开闭原则 （The Open/Close Principle, OCP）
- 可被替换原则 （Liskov Substitution Principle, LSP）
- 接口分离原则 （Interface Segregation Principle, ISP)
- 依赖反转原则 （Dependency Inversion Principle, DIP)

这五个原则指导着我们设计的每一个接口，类以及我们如何对现有代码进行持续重构优化，从而达到最佳的代码可伸缩，可测试以及高可复用等目标。

#### 单一职责原则 （SRP）

单一原则要求每一个类都应该有唯一且明确的职责定义，对其职责的改变需要有明确的原因。

这个原则的定义是为了避免定义一个粗线条的超大类并负责多种角色的反模式，设想你刚加入一个公司接管一个项目，如果你没能对其代码完全掌控，那么原因是什么？很可能就是其中几个几千行的类。到你离开或者这个产品被放弃，可能这些类都无法被重构优化，只要这些怪兽类存在问题，我们就必须拼尽体力去不断查日志并加断点调试，猜问题可能出现在哪里。

形成超大类可能有很多原因，一个核心的问题在于OOP将数据结构以及行为封装在一起，问题在于这样对数据接口及其行为的封装不仅仅弱化了组合、聚合在代码灵活可复用的作用，并且将问题隐藏在其内部。最终结果是面向对象代码中经常包括很多数据结构类并带有非常多的方法。

有的项目里会有很多叫Service、Manager、Helper的类，除非团队大家对这些类的角色、职责有非常明确且一致的定义，否则这些类极有可能会生长为巨兽级别的类，因为似乎什么方法都可以放到里面，本来Manager就是应该做很多事情的么。

#### 开闭原则 （OCP）

开闭的意思是对外开放扩展性，而封闭变化，开闭原则就是指我们设计的类应允许外部可以容易的对其进行扩展，同时对类自身的改动也不会影响到外部的其他类，反之外部类的任何改动也不应该影响到这个类的内部。

对已有的类的改动应该仅仅因为这个类自身的bug或者因为需求的改变对其做的调整，这个OCP中的封闭原则。开放的概念则是允许以重用代码的目的对一个类进行继承，或者以注入接口实现的方式对类本身进行扩展。然而通过以继承的形式实现代码重用往往会增加其实现的复杂度，因为很多时候要想确保一个类的方法可以安全的被重载需要基类在设计时考虑更多的因素，尤其是对状态的控制，想想面向对象编程的思路是允许代码以命令行的方式运行，通过代码更改可变量从而实现用状态控制对象行为。我们稍后介绍的LSP原则对继承。

这个思想其实可以延伸一下，当我们设计的不仅仅是一个类而是一个组件，open／close 原则同样也是需要被考虑的，组件需要对外提供必要的接口隔离自身的变化并尽量确保接口的向下兼容性，而对外提供良好的可扩展性同样需要定义清晰的接口供外部实现并注入回组件实现扩展型。有一个比较简单的原则就是组件的扩展性应该一视同仁，即自己如何扩展这个功能，那么外界也应该可以用相同的方式实现同样的功能。例如实现一个主题导航组件，那么导航组件自己提供的默认导航项的实现和创建方式，应该与业务逻辑添加其它导航项的方式保持一致。这个原则将避免组件自己有上帝模式，或者是自己的个性使之可以尽可能多的满足更多的需求，且这个一致性就像是乐高玩具一样，由有限种类的零件可以灵活组合出无限中可能。

#### 可被替换原则 （LSP）

可被替换原则指程序中的任何一个对象应该可以被任何一个自身的子类的对象替换而不会影响整个程序的稳定性和正确性。即子类应尽量保证仅对基类进行扩展，而避免改变父类方法的行为（如果一个方法父类返回true，则同样的上下文下子类的相同方法应该也为true）。遵守LSP原则是为了让我们避免破坏基类的封装性的前提下重用现有代码。

Kotlin语言默认所有方法和属性不可以被重载的目的就是确保所有的重载行为都需要是被设计的，在设计类的时候就应该充分考虑哪些方法可以被安全的重载。要求这样的原因就是要确保LSP原则。要做到这点需要保证父类对外支持的能力其子类必须同样满足，子类不能有任何的假设，子类必须接受所有父类声明接受的属性，并初始化自己及基类的状态。而这些原则是无法通过语法和静态检测来保证的，必须是在设计环节被考虑进来。

#### 接口分离原则 （ISP）

接口分离原则含义是一组由客户方定义的接口好于一个通用接口，没有地方使用的接口就不应该存在，而基于通用的目将非常多的方法定义在一个接口中会造成一方面，使用此接口的地方其实只会用到一两个方法，另一方面实现这个接口的类也因此要实现这个接口下的所有方法。

本质上ISP是针对接口版本的单一职责原则（SRP）他们都试图解决同样的问题，在面向对象设计中平衡职责划分、组合接口以及合并是非常困难的一件事情，有时一个类或者方法的命名的不够准确和恰当都会打破最优的平衡。

#### 依赖倒转原则 （DIP）

依赖反转原则也被称为面向抽象编程，即不要依赖具体的某一个实现编程，而是尽可能的依赖抽象类或者接口进行编程，换种说法就是要依赖抽象模型和接口进行编程。举个最简单的例子，假如我们的组件仅仅需要从Person对象获得name的值，就仅仅对Person类编程，不要针对其子类Customer和Employee（Person抽象类的更具体的实现），而如果我们开发的是员工系统而必须使用Employee模块，则仅仅在有必要的情况下针对Employee进行编程，例如需要从Employee对象中获取工号。

之所以叫依赖倒转的含义是将子类实现看作基类来用，对象实际上是实现层的类被转换成抽象层的类来使用被比喻称为一种反转。

上面的DIP是面向对象设计中的依赖反转原则。而在程序运行期，对象和对象之间的依赖关系的建立同样存在一种依赖反转的原则依赖控制反转，是一个同样非常重要的原则，并且两个依赖反转的原则相互配合起来会给整个程序的可扩展性，可配置性和可测试性能力进行加成。而依赖控制反转指的是一个类对另外一个类的依赖不用他们两者之间决定，可以简单的理解为，A类如果需要一个B类的实例，则不在A类内部构造这个B类，而是仅仅声明一个属性或者在构造函数中声明一个B类的入参，由外部第三方组建负责构造A和B两个类并将B赋值给A对象，即完成依赖关系控制的反转，由内部反转到外部。而结合DIP运用的效果是，定义一个接口InterfaceB由B类来实现，这样A类内甚至都不会出现B类，仅仅针对InterfaceB进行编程，则A类根本不知道有B类的存在，却可以相互协作完成任务。而这个时候倘若想切换InterfaceB的实现为C类，我们只需要从外部构造C类作为InterfaceB给到A类就可以了，无需修改A类的任何代码，这也是一个符合开闭原则的实现，即开放扩展能力且隔离封闭变更。

抽象工厂以及依赖反转容器（IOC）都是精心设计的可以辅助我们完成两个依赖反转原则的好帮手。这里不得不说Spring Framework中的核心组建IOC，是一个历史悠久且非常强大的IOC容器，当然IOC容器不止Spring Framework有，我之前也使用ObjectC语言开发了IOC容器帮助IOS的项目实现组建化和接口注入工作。

#### 上帝模式 VS 扩展

上帝模式是指我们已经知道我们要实现的功能的全部细节，并针对需求直接进行实现。例如我们已经回到我们要开发的界面中要出现确定和取消按钮，因此我们直接在代码中实现按钮的布局、命名以及点击事件的处理逻辑。这样做在第一时间是用最直接和简单的方式实现了我们的需求，但是其实这样看似简单直接的实现恰恰缺失最没效率的代码。一个代码是否足够的有效我们可以通过代码的生命力、适应变化的能力来衡量，如果你这个版本写的代码，下一个版本就要修改或者就被删除了，那其实这是个无效的代码。而开了上帝模式的代码最有可能是一个低效的代码。

扩展是指通过对增加对已有接口的实现，并在运行时将新的接口实现注入到已有的逻辑中，新的变化的引入并不是通过变更已有的代码的方式实现的，而是通过增加新的独立的接口实现类来扩充已有组件的功能。新的接口的实现可以在运行时通过专门的组件工厂方法在构造组件的时候进行注入。这样我们就引入了运行时变化来提供更多的灵活性，获得这样的灵活性的唯一的代价仅仅是引入了工厂模式，同时要遵守依赖反转原则并使用依赖注入技术。而付出总会有收获，这些额外的付出在提供运行时的扩展能力的同时，也增加了软件的可单元测试性，可维护性。

一个开发周期仅仅有两三个月的项目，往往是不需要考虑这么多的，因为你做的这些努力都是在为将来打基础，如果一个周期仅有几个月的简单产品这么投资就有些多余，我们等不到丰收的时候。但是像类似微信这样的用户量很大且产品周期很长的软件的时候呢？通过合理的运用设计模式，模型驱动来设计稳定和可复用的高效代码就是项目成功的必要条件了。

当我们开发软件的时候，面对一个全新的需求经常会使用一次性思维来实现我们代码，一次性思维往往是一种线性的思维，既通过顺序的推到解决问题的步骤来求解，并进行实现。通常情况下这样的解决方案在满足现有功能的前提下是最直接的也是步骤最少的（很多时候也未必时最简单的）。但是这样的实现往往缺乏对变化的适应能力，既对外来不友好的实现，因为很难对其进行扩展。当我们设计一个组件的时候，要切记消除不必要的假设。需要养成善于从日常的具体业务需求中提取出通用需求的习惯，为抽离出的通用的逻辑开发基础组件可以避免我们反复造轮子，但是如果我们实现的组件绑定了过多的行为则就会损失掉通用性。同时设计组件的时候必须明确组件本身的职责和边界，组件需要隐藏边界内的实现和变化，同时需要对边界外的需求提供友好的支持，就是通过定义清晰的接口和接口的注入机制对别边界外的需求提供扩展能力，这里体现了开闭原则的作用。

而这里的上帝模式是指同样一类功能，在边界内选择直接实现的同时又通过接口的形式开放给边界外进行扩展的功能，相对于接口扩展的形式，组件内部的另外一种实现实际上就是以上帝模式的另一种实现。
例如，我们需要开发一个控件来支持用户选择手机中的照片进行分享。看似简单的需求实际上蕴含着很多信息，我们这里可以简单的思考一下，到底哪些需求是业务需求而哪些是组件需求。

业务需求：
1）选择照片并进行分享。
2）从手机相册选择照片进行分享，可以选择多张。
3）分享照片
4）启动相机拍摄照片并分享
5）可以选择发送原图，否则默认发送压缩后的图片

组件需求：
1）支持以列表和方格布局的形式展现数据。
2）支持单选和多选。
3）支持图片的列表和方格展现空间。
4）记录选中项。
5）完成选择后的确定和取消交互控制。

当用不同的视角来看同一句话的时候，信息一下子就丰富了很多，通过这些信息我们来确定我们需要定义的接口、类以及每个接口和类的职责。

首先设计的组件不应该假设它知道如何加载资源，以及加载的是什么资源如何理解，而这里组件应该支持将资源以列表或者网格的形式展现在页面中。 因此这里应该定义一个ResourceProvider&lt;out T&gt;的接口来作为要加载的资源的提供者，因为ResourceProvider作为抽象的接口可以提供任何类型的模型对象，且ResourceProvider是一个模型实例的提供者，因此我们这里使用范型并使用kotlin中的out关键字。

 <pre><code>
 interface ResourceProvider&lt;out T&gt; {

    fun load(index: Int): T

    fun loadAll(): List&lt;T&gt;

    fun loadDatas(index: Int, count: Int): List&lt;T&gt;

    fun count(): Int
}
 </code></pre>

有了数据的提供者，我们还需要定义一个与之匹配的接口来帮助我们根据UI的需求布局每一项的数据应该展现什么样子，以及如何将模型中的属性值设置到正确的UI控件上完成数据的显示的。这里我们同样定义一个带有范型声明的接口ResourceItemLayout&lt;T&gt;.

<pre><code>
interface ResourceItemLayout<in T> {

    fun getViewFillWith(data: T): View

}
</code></pre>

熟悉android开发的人应该对BaseAdapter接口并不陌生，这里BaseAdapter的职责是为列表控件提供具体要展现的列表项的视图，即要通过Adapter帮助列表控件将不同的模型中的数据适配到列表项的View控件中。因此我们这里定义一个类继承自BaseAdapter并接受一个ResourceProvider来作为数据的提供者。

<pre><code>
class ResourceAdapter<T>(var provider: ResourceProvider<out T>,
                         var itemLayout: ResourceItemLayout<in T>): BaseAdapter() {
    override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {
        return itemLayout.getViewFillWith(provider.load(position), convertView, parent)
    }

    override fun getItem(position: Int): Any {
        return provider.load(position) as Any
    }

    override fun getItemId(position: Int): Long {
        return position.toLong()
    }

    override fun getCount(): Int {
        return provider.count()
    }
}
</code></pre>

组件应该处理用户的单选和多选操作并记录到底哪些资源项被用户选中了，但是资源项被选中状态应该是什么样子其实是个UI的需求，因此这里需要一个接口来完成当特定资源项被选中／取消选中的事件通知到资源项控件的工作。因此组件中定义了一个Selectable接口，每一个数据项的View应该实现这个接口以此来对选中状态进行相应

<pre><code>
interface Selectable {
    // 由于列表滚动时，View会被重用，因此View的选中状态会被频繁的设置，因此这里使用set会比onSelectStateChange等方法名更加合适
    fun setSelectStateChange(isSelected: Boolean)
}
</code></pre>



## 领域驱动设计 （DDD）
领域驱动模型是一种通过对特定领域知识进行抽象建模，并开发专门的引擎驱动模型实现需求的方式。通过关注特定的领域从而确定需要解决的问题的边界，我们可以对其建模。建模的过程就是对领域中的需求进行抽象从而提炼出名词实体以及术语，使得我们可以不断的使用有限的名词实体和术语的组合出产出无尽的表达能力丰富灵活的业务模型。

领域广义上解释就是对特定的独立的问题划定的一个范围，一个领域通常都有清晰的边界即上下文，定义的模型可以很好的通过有限的元素（实体，数据接口，术语，策略，规则）不断的组合来描述边界内的所有需求以及方案。

领域模型中的概念:

- 上下文（Context）通常同一个词汇运用在不同的地方（模型）会有不同的含义，因此模型中的元素都带有一个上下文，上下文描述当一个词汇出现在某处的时候其含义被确定为某个具体的含义。
- 领域 （Domain）一个特定且独立的实体、环节或者模块。领域是可以被定义出来的主题明确且独立的范围，领域划分的界限代表模型所要概括的知识以及系统的职责的边界。
- 模型 （Model）一个由抽象化的有限元素和术语组成的子系统，用于描述特定领域中的概念并且可以通过不断的组合解决领域内的实际问题。
- 通用语言（Ubiquitous language）通用语言是一种围绕特定领域结构化的沟通语言，一种可以被项目团队中所有成员使用的沟通语言。

使用领域驱动设计的方式可以使得整个项目成员优先关注最最重要和核心的领域和领域中的逻辑，而基于优化后的模型进行复杂设计有助于在实现复杂多变的业务逻辑的同时使得整体实现更加有序，用于描述领域模型的通用语言又同时提高了团队沟通效率（效率包括速度以及准确度）。我们既可以把领域模型理解为设计文档，同时一个可以被引擎解析并驱动的模型又是我们产品的一部分，这使得我们以最直接的方式将设计转化为了代码，或者说两者在领域模型中是合一的。

领域不仅仅来源于用户的直接需求，即使你专门研究过领域驱动设计，但其实你已经在运用它了只是你没有意识到，因为很多领域模型都是面对开发的，例如UML模型就是面向对象设计领域的领域模型，状态机模型则是状态控制的领域模型。我们下面介绍一些与我们平时开发相关的领域模型，领域相关的框架，并介绍Kotlin语言在DDD开发中发挥的作用（DSL）。

### UML模型

UML模型面对的领域是面向对象设计，基于有限的元素类、接口、组件，用例，角色，实例，以及有限的术语继承、实现、引用、组合、聚合等概念对基于面向对象思想设计进行建模，通过不断的组合这些元素我们可以定义出类图、时序图、组件图、通信图、发布拓扑图、状态机图、活动图等，这些设计图最终成为一种通用的语言来完成对OOP设计的描述使得我们可以相互间将设计思想进行高效准确的沟通和交流，并最终将产生的知识固化下来，辅助我们理解和实现我们的代码。

UML模型包括定义一组标准的图元与上面的元素以及概念一一对象来绘制设计图，使用通用的语言对模型进行描述，并且专著于解决具像化图形化设计这一领域。

尤其是在一个项目或者一个模块的设计初期，我们需要进行大量的交流的时候，使用UML图来消除奇异并缺明确方案就显得尤为重要。有的时候，两个人虽然已经进行了非常频繁的口头交流，并切相互表示完全理解明白对方说的意思以及达成共识，但是最后发现开发的代码其实根本不是对方认为的样子。很好的运用UML模型来表达你的设计，可以让我们仅仅通过初期的设计就能确定我们最终开发的代码会是什么样子，到底有哪些接口，哪些组件以及他们的依赖关系和生命周期维护等信息。

下面我们用类图来描述一个使用策略模式定义的一个业务模型，这里也体现了使用领域驱动设计代码的一个好处，就是领域模型具有将隐藏概念和知识清晰化的优势。

我们介绍一个简单的例子使用UML来表达我们的设计，并尝试进行领域模型的抽取。我们从一个简单的领域模型设计开始，基于此模型的系统用来预定一艘船在一次航程中要运载的货物如图：

<img src="./images/ddd_model1.png">

我们规定这个应用程序的任务是将每件货物（Cargo）与一次航程（Voyage）关联起来，记录并跟踪这种关系，目前看非常简单，但是实际的需求中还有些隐含的概念。例如我们最终的代码中很可能会有一些这样的逻辑：

<pre><code>
fun Int makeBooking(cargo: Cargo, voyage: Voyage): Int {
    val confirmation = orderConfirmationSequence.next()
    voyage.addCargo(cargo, confirmation)
    return confirmation
}
</code></pre>

由于总会有人在最后一刻取消订单，因此航运业的一般做法是接受比其运载能力多一些的货物。这被称作“超订”。一种方式是使用一个简单的百分比来表示允许超订的范围，如允许预订110%的载货量。而有时则会采用更佳复杂的规则（主要客户或特定种类的货物优先）。

这是航运领域的一个基本策略，从事航运业的业务人员都知道这个知识点，但在软件团队中可能不是所有技术人员都知道这条规则。需求文档中对其描述可能仅仅只有语句：允许10%的超订。我们很容易就会忽略这个超订的概念并切无法意识到，这个超订并不与10%这个规则等同，即10%的超订只是超订的一种规则或者是策略。

现在我们就应该修改我们的类图和代码如下：

<pre><code>

data class Voyage(var capacity: Double)

data class Cargo(val size)

fun Int makeBooking(cargo: Cargo, voyage: Voyage): Int {
    val maxBooking = voyage.capacity * 1.1
    if ((voyage.bookedCargoSize() + cargo.size) > maxBooking) {
        return -1
    }
    val confirmation = orderConfirmationSequence.next()
    voyage.addCargo(cargo, confirmation)
    return confirmation
}
</code></pre>

<img src="./images/ddd_model1_class.png">

现在一个重要的业务规则被隐藏在了上面这段方法的代码的一个卫语句中，隐藏的还不仅仅是这些，就连10%这个信息都被隐藏在了1.1这个硬编码的数字中，同时这个超订的额度也无法进行更改，必须通过对代码的修改才可以变更。设想我们虽然将系统交付给了最终用户，但是当用户想调整超订范围的时候会有多么的无奈，用户必须找到我们重新修改代码并编译才可以进行调整。如果业务规则被隐藏在这段代码中，业务专家不可能通过检查代码来检测规则是否正确，即是在开发人员帮助下也无法完成，因为它非常隐蔽。同时非业务的技术人员也很难将需求文档与代码进行联系。因此我们这里要考虑如何把这条规则转移到领域对象中，并让项目中的每个人都能清楚并理解它。

我们可以改变一下设计来更好的捕获这个知识，我们将超订这个概念定义为一个策略。策略（policy）其实就是设计模式中的策略模式（Strategy）。

<img src="./images/ddd_overbooking_policy.png">

<pre><code>
fun makeBooking(cargo: Cargo, voyage: Voyage, policy: OverbookingPolicy) {
    if (!policy.isallowed(cargo, voyage)) return -1
    val confirmation = orderConfirmationSequence.next()
    yoyage.addCargo(cargo, confirmation)
    return confirmation
}
</code></pre>

这里我们由领域模型驱动设计，将超订这个需求提炼成为策略元素，并定义抽象层OverbookingPolicy类来对应超订这个知识，只要任何实现了isallowed方法的子类都可以作为规则应用到程序中从而实现了可配置和扩展的能力。

现在所有人都清楚超订是一个独特的策略，而且超订规则的实现即明确而又独立。而UML图则充分的从面相对象设计的角度表达了我们的想法。

### 领域模型层

### 业务流程模型 （Business Process Model）

业务流程模型是针对于企业的流程类需求定义的一种领域模型，通过将流程进行抽象，模型化定义流程，并开发专用的流程引擎负责解析执行。领域模型定义了（Activity）、任务（Task）、路径（Transaction）、路由节点（Router）等元素，所有的流程模型都可以由上面的这些元素组合连接起来形成一个业务流程。

最典型的业务流程就是报销流程，用户创建一个报销工单，通过员工的负责人审批，财务审批、以及最后的支付环节来完成整个报销流程。当一个环节结束后，下一个环节的处理人就会产生一个代办任务。

最简单的流程图如下：

<img src="./images/bpm_model1.png">

与领域模型对应的UML设计图如下：

<img src="./images/bpm_process_classes.png">

ProcessDefinition是流程定义类，一个流程定义包括由多个被Transaction（单向路径）连接起来的Activity活动组成，每个流程都有唯一的一个开始环节和结束环节，而每一个活动都可以触发一个Task的执行，因此当Task运行结束后会根据执行的结果选择可以通过的路径（Transaction）从而激活下一个环节。

可以把流程理解为一个有向图，而我们可以通过选择一个流程定义作为模型启动一个流程实例，同一时刻流程实例仅有一个活动被激活，当一个活动结束后则需要进行路由选择从而使得激活状态从一个环节转移到另一个环节，知道进行到结束环节则整个流程被结束。

类图中的圆圈代表接口，UML中定义个两个接口，一个是任务接口Task，一个是流程实例接口ProcessInstance。

定义Task的作用是为了提供扩展能力，引擎会提供基本的Task实现,如HumanTask, EmailTask, AutomaticTask等，与此同时实际业务开发者还可以根据用户的需求实现自己的Task行为，通常情况下一个流程可以使用XML来进行描述，只要在XML中指定Task具体实现的类，我们就可以开发一个使用类反射机制将制定的类作为Task接口的实现继承入用户定义的流程中。

TODO 介绍Kotlin的类反射

定义ProcessInstance接口的作用是隔离模型和驱动模型流转引擎的实现，使得我们可以随时根据需求和选择来切换流程引擎的具体实现，这样使得我们同样的模型可以被应用到不同环境下的流程引擎中去，比如手机端，专有服务器或者云端。这样只要我们能保证基于ProcessInstance接口来实现对流程的管理和控制，就可以随时切换成不同的环境和引擎而达到不对现有业务进行大范围调整的风险，以此来达到满足开闭原则（OCP）和可被替换原则（LSP）。

整个工作流模型和引擎的设计遵循着依赖反转原则，工作流模型是在流程业务领域中的高度抽象的模型，而工作流引擎则是面向这一高度抽象的模型进行编程的产物，因此工作流引擎是一个依赖反转原则（DIP）很标准的一个运用。（DIP原则可以用在任何一个微小的设计上）


TODO 介绍kotlin中的扩展在工作流模型中是否有更好的运用。函数式编程如何加强工作流模型

这样一个模型基本涵盖了一个流程所需要的基本元素，同时这个模型其实也可以用来描述一个状态机模型。如果我们把环节的概念切换成状态，整个模型就可以用来描述一组状态改变的规则。很多时候我们会用单个枚举变量或者一组枚举来为多个模块提供一个整体的状态控制，也就是我们用公共变量控制和驱动多个类的协同工作。这样的设计有一个很不好的缺点就是对状态的改变和控制会被分散到各处的代码中，代码未能显示的描述出状态控制的逻辑和规则，如果由多个模块在多个线程下都通过更改这样的状态变量来影响全局的状态，则一旦出现bug则很可能非常难于分析和解决。因为很可能多个程序员开发的类都依赖且同时影响同一个状态，很可能没有人知道全部的状态改变的行为。一旦某一个类在不恰当的时机改变了这个状态，整个模块就可能进入到一个错误的状态，或者进入到一个无法恢复的异常状态。

## 设计模式

这里设计模式中的模式有两层含义，一是指我们对某一特定问题的一个归类，因此一个模式必然尤其自己固有的且特定的特征和特性。另一种含义是当我们识别出这种特定的问题后，有一种一对一的专有方案或者原则可以很好的作为我们设计工作的指导来解决这一特定的问题或者需求。因此，设计模式指的就是我们将软件设计相关的问题归纳分类成为很多可以被识别出来的特定模式，并一对一总结出特定的方法（模式）进行解决。同时设计模式与领域驱动模型一样也是一种通用语言，设计模式相当于是开发人员交流架构设计的一种通用语言，我们在运用这一通用语言进行沟通时，同时传递着设计原则，架构思想以及最重的代码实现方案（算法除外），神奇的是这些信息有的时候可以仅仅使用一个词就可以同时代表，它是如此的自然以至于大多数时候我们都全然不知。


