#  OOP面向对象编程

## OOP设计原则

这小结我们会介绍几个面向对象基本的设计原则，这些原则是经过多年众多行业经营总结出来的基础的原则，他们就像物理学家们定义的物理公式一样，它们都如此的简单且优美，但却非常广泛的影响着我们编写的每一行代码。

通常，OOP方式的两种被指责的反模式是：
- 通过类将一种数据格式及其行为进行绑定，从而将状态封装在其内部进行维护是一种将问题隐藏起来而不是解决问题，因为可变状态会带来副作用。
- 面向对象偏向设计一个合理的类之间的继承关系来达到最大限度的代码重用和多态化，但是继承并不是最好的实现多态及代码高可重用的方式。

OOP通过SOLID和DDD这两大原则来解决上面的问题，SOLID中的每个字母都是一个原则的首字母,而DDD则是领域驱动设计(Domain-driven Design)的缩写，我们下面来一一向大家介绍。

### SOLID

SOLID包括如下五个原则

- 单一职责原则 （Single Responsibility Principle, SRP）
- 开闭原则 （The Open/Close Principle, OCP）
- 可被替换原则 （Liskov Substitution Principle, LSP）
- 接口分离原则 （Interface Segregation Principle, ISP)
- 依赖反转原则 （Dependency Inversion Principle, DIP)

这五个原则指导着我们设计的每一个接口，类以及我们如何对现有代码进行持续重构优化，从而达到最佳的代码可伸缩，可测试以及高可复用等目标。

#### 单一职责原则 （SRP）

单一原则要求每一个类都应该有唯一且明确的职责定义，对其职责的改变需要有明确的原因。

这个原则的定义是为了避免定义一个粗线条的超大类并负责多种角色的反模式，设想你刚加入一个公司接管一个项目，如果你没能对其代码完全掌控，那么原因是什么？很可能就是其中几个几千行的类。到你离开或者这个产品被放弃，可能这些类都无法被重构优化，只要这些怪兽类存在问题，我们就必须拼尽体力去不断查日志并加断点调试，猜问题可能出现在哪里。

形成超大类可能有很多原因，一个核心的问题在于OOP将数据结构以及行为封装在一起，问题在于这样对数据接口及其行为的封装不仅仅弱化了组合、聚合在代码灵活可复用的作用，并且将问题隐藏在其内部。最终结果是面向对象代码中经常包括很多数据结构类并带有非常多的方法。

有的项目里会有很多叫Service、Manager、Helper的类，除非团队大家对这些类的角色、职责有非常明确且一致的定义，否则这些类极有可能会生长为巨兽级别的类，因为似乎什么方法都可以放到里面，本来Manager就是应该做很多事情的么。

#### 开闭原则 （OCP）

开闭的意思是对外开放扩展性，而封闭变化，开闭原则就是指我们设计的类应允许外部可以容易的对其进行扩展，同时对类自身的改动也不会影响到外部的其他类，反之外部类的任何改动也不应该影响到这个类的内部。

对已有的类的改动应该仅仅因为这个类自身的bug或者因为需求的改变对其做的调整，这个OCP中的封闭原则。开放的概念则是允许以重用代码的目的对一个类进行继承，或者以注入接口实现的方式对类本身进行扩展。然而通过以继承的形式实现代码重用往往会增加其实现的复杂度，因为很多时候要想确保一个类的方法可以安全的被重载需要基类在设计时考虑更多的因素，尤其是对状态的控制，想想面向对象编程的思路是允许代码以命令行的方式运行，通过代码更改可变量从而实现用状态控制对象行为。我们稍后介绍的LSP原则对继承。

这个思想其实可以延伸一下，当我们设计的不仅仅是一个类而是一个组件，open／close 原则同样也是需要被考虑的，组件需要对外提供必要的接口隔离自身的变化并尽量确保接口的向下兼容性，而对外提供良好的可扩展性同样需要定义清晰的接口供外部实现并注入回组件实现扩展型。有一个比较简单的原则就是组件的扩展性应该一视同仁，即自己如何扩展这个功能，那么外界也应该可以用相同的方式实现同样的功能。例如实现一个主题导航组件，那么导航组件自己提供的默认导航项的实现和创建方式，应该与业务逻辑添加其它导航项的方式保持一致。这个原则将避免组件自己有上帝模式，或者是自己的个性使之可以尽可能多的满足更多的需求，且这个一致性就像是乐高玩具一样，由有限种类的零件可以灵活组合出无限中可能。

#### 可被替换原则 （LSP）

可被替换原则指程序中的任何一个对象应该可以被任何一个自身的子类的对象替换而不会影响整个程序的稳定性和正确性。即子类应尽量保证仅对基类进行扩展，而避免改变父类方法的行为（如果一个方法父类返回true，则同样的上下文下子类的相同方法应该也为true）。遵守LSP原则是为了让我们避免破坏基类的封装性的前提下重用现有代码。

Kotlin语言默认所有方法和属性不可以被重载的目的就是确保所有的重载行为都需要是被设计的，在设计类的时候就应该充分考虑哪些方法可以被安全的重载。要求这样的原因就是要确保LSP原则。要做到这点需要保证父类对外支持的能力其子类必须同样满足，子类不能有任何的假设，子类必须接受所有父类声明接受的属性，并初始化自己及基类的状态。而这些原则是无法通过语法和静态检测来保证的，必须是在设计环节被考虑进来。

#### 接口分离原则 （ISP）

接口分离原则含义是一组由客户方定义的接口好于一个通用接口，没有地方使用的接口就不应该存在，而基于通用的目将非常多的方法定义在一个接口中会造成一方面，使用此接口的地方其实只会用到一两个方法，另一方面实现这个接口的类也因此要实现这个接口下的所有方法。

本质上ISP是针对接口版本的单一职责原则（SRP）他们都试图解决同样的问题，在面向对象设计中平衡职责划分、组合接口以及合并是非常困难的一件事情，有时一个类或者方法的命名的不够准确和恰当都会打破最优的平衡。

#### 依赖倒转原则 （DIP）

依赖反转原则也被称为面向抽象编程，即不要依赖具体的某一个实现编程，而是尽可能的依赖抽象类或者接口进行编程，换种说法就是要依赖抽象模型和接口进行编程。举个最简单的例子，假如我们的组件仅仅需要从Person对象获得name的值，就仅仅对Person类编程，不要针对其子类Customer和Employee（Person抽象类的更具体的实现），而如果我们开发的是员工系统而必须使用Employee模块，则仅仅在有必要的情况下针对Employee进行编程，例如需要从Employee对象中获取工号。

之所以叫依赖倒转的含义是将子类实现看作基类来用，对象实际上是实现层的类被转换成抽象层的类来使用被比喻称为一种反转。

上面的DIP是面向对象设计中的依赖反转原则。而在程序运行期，对象和对象之间的依赖关系的建立同样存在一种依赖反转的原则依赖控制反转，是一个同样非常重要的原则，并且两个依赖反转的原则相互配合起来会给整个程序的可扩展性，可配置性和可测试性能力进行加成。而依赖控制反转指的是一个类对另外一个类的依赖不用他们两者之间决定，可以简单的理解为，A类如果需要一个B类的实例，则不在A类内部构造这个B类，而是仅仅声明一个属性或者在构造函数中声明一个B类的入参，由外部第三方组建负责构造A和B两个类并将B赋值给A对象，即完成依赖关系控制的反转，由内部反转到外部。而结合DIP运用的效果是，定义一个接口InterfaceB由B类来实现，这样A类内甚至都不会出现B类，仅仅针对InterfaceB进行编程，则A类根本不知道有B类的存在，却可以相互协作完成任务。而这个时候倘若想切换InterfaceB的实现为C类，我们只需要从外部构造C类作为InterfaceB给到A类就可以了，无需修改A类的任何代码，这也是一个符合开闭原则的实现，即开放扩展能力且隔离封闭变更。

抽象工厂以及依赖反转容器（IOC）都是精心设计的可以辅助我们完成两个依赖反转原则的好帮手。这里不得不说Spring Framework中的核心组建IOC，是一个历史悠久且非常强大的IOC容器，当然IOC容器不止Spring Framework有，我之前也使用ObjectC语言开发了IOC容器帮助IOS的项目实现组建化和接口注入工作。


## 领域驱动设计 （DDD）

